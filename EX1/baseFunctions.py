# -*- coding: utf-8 -*-
"""
Created on Fri Dec 18 22:59:59 2020

@author: Christian
"""




import numpy as np
import random
import copy
import matplotlib.pyplot as plt
import seaborn as sns

np.random.seed(4)


def init_map(pZero, N):
    # Each row and column corresponds to an intersection on our map.
    # A zero means that there is no connection.
    # A Xij value means it takes X time to get fromm node i to node j
    
    #
    # np.random.seed = 4random.random()
    # Create a symetrical matrix
    tempArray = np.random.random([N,N])
    np.fill_diagonal(tempArray,0)
    
    mapping = (tempArray + tempArray.T) / 2
       
    # get the values less than our threshold probaility
    indexes = np.where(mapping < pZero )
    
    # scale up the numbers sysmetrically
    tempArray = np.random.random([N,N])*5
    mapping = mapping*(tempArray + tempArray.T) 

    mapping[indexes] = 0
    # mapping

    ax = sns.heatmap(mapping)

    plt.show()



    return mapping
    # np.where(mapping < )
    

    

def fitness(route, mapping):
    Npoint = len(route)
    Indexes = np.arange(Npoint)
    
    # Get the next route entry
    shiftedIndex = Indexes[:-1] + 1
    shiftedRoute = route[shiftedIndex]
    
    # Find all of the first nodes, then for those find the distance of the second shifted node
    distances = mapping[route[:-1], shiftedRoute]
    dist = np.sum(mapping[route[:-1], shiftedRoute])
    
    return dist



 
    
    
def genereateValidRoute(startID, endID, mapping):
    # route can't pass through zeros
    # This assumes that there is a valid solution! There might not be one.
    
    # Do a random walk through the network
    go = True
    currentNode = startID
    solution = [currentNode]
    
    while go == True:
        currentNodeMap = mapping[currentNode] 
        connectedNodeIndex = np.where(currentNodeMap != 0)[0]
        nextNode = np.random.choice(connectedNodeIndex)
        # nextNode  = currentNodeMap[nextNodeIndex]
        
        solution.append(nextNode)
        
        if  nextNode == endID:
            go = False
        
        currentNode = nextNode
        
    return np.array(solution)


def generate_Starting_Population(size, start, end, mapping):
    
    #this just creates a population of different routes of a fixed size.  Pretty straightforward.
    
    population = []
    
    #TODO: vectorize this function
    
    for ii in range(size):
        population.append(genereateValidRoute(start, end, mapping))
        
    return population



# def initialize_complex_map(p_zero, N, groups):

#     the_map = np.zeros((N,N))
    
#     for ii in range(0, N):
#         for jj in range(0, ii):
#             group_i = int(ii/(N/groups))
#             group_j = int(jj/(N/groups))
            
#             if random.random() > p_zero and abs(group_i - group_j) <= 1:
#                 the_map[ii][jj] = random.random()
#                 the_map[jj][ii] = the_map[ii][jj]
          
        
#     ax = sns.heatmap(the_map)

#     plt.show()
        
#     return the_map

def crossover(a, b, start, end):
    
    # This function allows us to generate two new solutions by swaping two
    # old solutions
    # a and b.
    
    # The new solution is generated by finding a common point on the path bewtween
    # the two older solutions, then slicing the cunction at that point
    
    common_elements = set(a) & set(b)
    
    aOut = np.zeros_like(a)
    bOut = np.zeros_like(b)
    
    # our new solution must have at least one valid swap. We can't swap at
    # the start point, or end point    
    if len(common_elements) == 2:
        return (a, b)
    
    common_elements.remove(start)
    common_elements.remove(end) 
    # pick a sample
    # value = random.sample(common_elements, 1)        
    value = np.random.choice(list(common_elements))   
    
    # Get the first cur value
    cutA = np.random.choice(np.where(a == value)[0])
    cutB = np.random.choice(np.where(b == value)[0])
    
    # Concetenate makes a new object, no need for copies.
    aOut = np.concatenate([a[:cutA], b[cutB:]])
    bOut = np.concatenate([b[:cutB], a[cutA:]])
    
    return (aOut, bOut)


#TODO:
#   Consider a function for "checkValidRoute".



#TODO: Try some different mutation functions!
def mutate(route, threshold, mapping, end):
    
    # Generate a random number - if it is less than a threshold then recalculate the path
    # after a certain point.

    N = len(mapping)
    N = len(route)
    Pvector = np.random.random_sample(N)
    
    # Find the first value less than the threshold
    cutIndex = np.argmin(threshold < Pvector)
    
    cutNode = route[cutIndex]
    
    # generate a new route        
    newTail = genereateValidRoute(cutNode, end, mapping)
    
    newRoute = np.concatenate([route[:cutIndex], newTail])
    
    return newRoute
    
    # new_route = random.randint(1,10,[N,N])


def score_population(population, mapping):
    # Find scores for every item of hte pupulation
    
    scores = []
    
    for ii in range(len(population)):
        scores += [fitness(population[ii], mapping)]
        
    return np.array(scores)





def get_fitness_probailities(scores):
        # find wich scores should be combined
    # Scores with a low fitness should be combined at higher probability
    Npop = len(scores)   
    populationRanks = np.zeros(Npop)
    
    # sort the array, then create an array of ranks
    sortedIndexes = scores.argsort()    
    populationRanks[sortedIndexes] = np.arange(Npop)

    # the inverse of the fitness rank
    rankedFitness = Npop - populationRanks
    
    cumulativeFitness = np.cumsum(rankedFitness)
    probs = cumulativeFitness / cumulativeFitness[-1]
    
    return probs


def pick_mate(scores, probs):
    # Select a mamber of the pupulation at random depending on the ranked probability
    
    Nprobs = len(probs)
    rand = np.random.random()

    return np.argmax(rand < probs)

    # for ii in range(Nprobs):
    #     if rand < probs[ii]:
            
    #         return ii




def plot_best(the_map, route, iteration_number, start, end):
    ax = sns.heatmap(the_map)

    figsize = len(the_map)
    
    x=[start + 0.5] + [x + 0.5 for x in route[0:len(route)-1]] + [end - 0.5]
    y=[start + 0.5] + [x + 0.5 for x in route[1:len(route)]] + [end - 0.5]
    
    plt.plot(x, y, marker = 'o', linewidth=4, markersize=12, linestyle = "-", color='white')
    # plt.savefig('images/new1000plot_%i.png' %(iteration_number), dpi=300)
    plt.show()





# start = 0
# end = 20
    
# mapping = init_map(0.85,50)

# route1 = genereateValidRoute(start, end, mapping)
# route2 = genereateValidRoute(start, end, mapping)

# # The end shoudl be the end value

# route3, route4 = crossover(route1, route2, start,end)

# # Test 1
# # route3[-1]  == end & route4[-1] == end

# # Test 2
# # len(route4) +len(route3) - len(route1) - len(route2)

# route5 = mutate(route1, 0.05, mapping,end)
# # should be zero


# out = fitness(route1, mapping)




# print(out)
# print(mapping)
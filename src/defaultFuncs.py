# -*- coding: utf-8 -*-
"""
Created on Sun Dec 20 18:43:11 2020

@author: Christian
"""

import numpy as np
from .solutionClass import Individual



def initPopulation(size, genePool):
    """ Creates the first generation of the population"""
    gen = 0
    population = []
    for ii in range(size):
        genotype = genePool.getGenotype()
        population.append(Individual(genotype))
        
    namePopulation(population, gen)
        
    return population


class defaultEnvironment:
    """
    Stores conditions universal to all individuals.
    """
    
    def __init__(self):

        pass



def crossGene(genea, geneb):
    
    Nunits = max(len(genea), len(geneb))
    
    # pick a random cut point
    cut = np.random.choice(np.arange(Nunits))
       
    # Concetenate makes a new object, no need for copies.
    aOut = np.concatenate([genea[:cut], geneb[cut:]])
    bOut = np.concatenate([geneb[:cut], genea[cut:]])
    
    return aOut, bOut
    
    
    
def defaultCrossover(a: Individual, b: Individual):
    
    """
    This function generates a new solution by swaping parts of the genotype in 
    two old solutions.
    
    The new solutions is 
    
    
    The default funcitons works for solutions a and b, where c is also a solution
    """
    
    # This function allows us to generate two new solutions by swaping two
    # old solutions a and b.
    
    # The new solution is generated by finding a common point on the path bewtween
    # the two older solutions, then slicing the cunction at that point
    
    genotypea = a.genotype
    genotypeb = b.genotype
    Ngenes = a.Ngenes
    
    aOut = [None]*Ngenes
    bOut = [None]*Ngenes
    
    for ii in range(Ngenes):
        aOut[ii], bOut[ii] = crossGene(genotypea[ii], genotypeb[ii])
        
    return (Individual(aOut), Individual(bOut))


def defaultFitness(individual, env):
    """ In this case getting fitness from our result is trivial
    """       
    
    fitness = individual.result
    return fitness




def mutateGene(individual, oldGene, tempGene, threshold):
            # for each value we randomly mutate depeding on the threshold.
        N = len(oldGene)
        Pvector = np.random.random_sample(N)
        
        # Get the genotype and a new genotype

        newGene = np.zeros(N)
        
        # Find the first value less than the threshold
        
        # Find the values that were mutated, assign them values form the new gene.
        mutateIndexes = np.where(Pvector < threshold)
        newGene[mutateIndexes] = tempGene[mutateIndexes]
        
        
        mask = np.ones(N, np.bool)
        mask[mutateIndexes] = 0
        newGene[mask] = oldGene[mask]
        
        return newGene
        


def defaultMutate(individual, threshold, GenePool):
    
    """
    Mutate will randomly generate a new solution based on the old solution.
    
    The default mutate function generates valid solutions where the solution
    is an array of inputs:
        X = [x1, x2, x3, ..., xN]
    
    And, that array for two valid solutions X and Y, the solution Z is also a 
    solution
        Z = [y1, x2, x3, y4, ..., yN]
 
    """   
    
    # Given an individual, randomly create a new solution
    Ngenes = len(individual.genotype)
    newGenotype = [None]*Ngenes
    tempGenotype = GenePool.getGenotype()
    
    
    for ii in range(Ngenes):
        oldGene = individual.genotype[ii]
        tempGene    = tempGenotype[ii]
        newGenotype[ii] = mutateGene(individual, oldGene, tempGene, threshold)

    
    return Individual(newGenotype)


# =============================================================================
# Default evaluation functions
# =============================================================================
"""
Thes functions are used to work with individual containers
"""

def defaultFitnessProbs(scores):
    
    """
    This works for any possible value of scores.
    
    The probability of each selection is assigned, assuming we wish to minimize scores.
    
    This takes the score and assignes a rank 1-N based on the score.
    A cumulative distribution is then created by summing the inverse of each rank
    and dividing by the total sum of ranks.
    
    Each point in the output array has width equal to the liklihood of it being
    chosen.
    
    
    """
    
    # find wich scores should be combined
    # Scores with a low fitness should be combined at higher probability
    Npop = len(scores)   
    populationRanks = np.zeros(Npop)
    # print(scores)
    # sort the array, then create an array of ranks
    sortedIndexes = scores.argsort()    
    populationRanks[sortedIndexes] = np.arange(Npop)

    # the inverse of the fitness rank
    rankedFitness = Npop - populationRanks
    
    cumulativeFitness = np.cumsum(rankedFitness)
    probs = cumulativeFitness / cumulativeFitness[-1]
    
    return probs

def pick_Individual(population, probs):
    # Select a mamber of the pupulation at random depending on the ranked probability
    rand = np.random.random()
    selection = population[np.argmax(rand < probs)]
    return selection

def namePopulation(population, gen):
    
    for ii, individual in enumerate(population):
        individual.name = int(ii)
        individual.gen = int(gen)
            
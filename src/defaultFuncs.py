# -*- coding: utf-8 -*-
"""
Created on Sun Dec 20 18:43:11 2020

@author: Christian
"""

import numpy as np
from .solutionClass import Individual



def initPopulation(size, genePool):
    """ Creates the first generation of the population"""
    gen = 0
    population = []
    for ii in range(size):
        genome = genePool.getGenome()
        population.append(Individual(genome))
        
    namePopulation(population, gen)
        
    return population


class defaultEnvironment:
    """
    Stores conditions universal to all individuals.
    """
    
    def __init__(self):

        pass

  
def defaultCrossover(a, b):
    
    """
    This function generates a new solution by swaping parts of the genome in 
    two old solutions.
    
    The new solutions is 
    
    
    The default funcitons works for solutions a and b, where c is also a solution
    """
    
    
    
    # This function allows us to generate two new solutions by swaping two
    # old solutions a and b.
    
    # The new solution is generated by finding a common point on the path bewtween
    # the two older solutions, then slicing the cunction at that point
    
    genomea = a.genome
    genomeb = b.genome
    Ngenes = len(genomea)
        
    aOut = np.zeros(Ngenes)
    bOut = np.zeros(Ngenes)
    
    # pick a random cut point
    cut = np.random.choice(np.arange(Ngenes))   
       
    # Concetenate makes a new object, no need for copies.
    aOut = np.concatenate([genomea[:cut], genomeb[cut:]])
    bOut = np.concatenate([genomeb[:cut], genomea[cut:]])
    
    return (Individual(aOut), Individual(bOut))


def defaultMutate(individual, threshold, GenePool):
    
    """
    Mutate will randomly generate a new solution based on the old solution.
    
    The default mutate function generates valid solutions where the solution
    is an array of inputs:
        X = [x1, x2, x3, ..., xN]
    
    And, that array for two valid solutions X and Y, the solution Z is also a 
    solution
        Z = [y1, x2, x3, y4, ..., yN]
 
    """   
    
    # Given an individual, randomly create a new solution
    
    # for each value we randomly mutate depeding on the threshold.
    N = len(individual.genome)
    Pvector = np.random.random_sample(N)
    
    # Get the genome and a new genome
    currentGenome = individual.genome
    tempGenome = GenePool.getGenome()
    
    # Find the first value less than the threshold
    mutateIndexes = np.where(Pvector < threshold)
    currentGenome[mutateIndexes] = tempGenome[mutateIndexes]
    
    return Individual(currentGenome)


# =============================================================================
# Default funcitons
# =============================================================================


def defaultFitnessProbs(scores):
    
    """
    This works for any possible value of scores.
    
    The probability of each selection is assigned, assuming we wish to minimize scores.
    
    This takes the score and assignes a rank 1-N based on the score.
    A cumulative distribution is then created by summing the inverse of each rank
    and dividing by the total sum of ranks.
    
    Each point in the output array has width equal to the liklihood of it being
    chosen.
    
    
    """
    
    # find wich scores should be combined
    # Scores with a low fitness should be combined at higher probability
    Npop = len(scores)   
    populationRanks = np.zeros(Npop)
    # print(scores)
    # sort the array, then create an array of ranks
    sortedIndexes = scores.argsort()    
    populationRanks[sortedIndexes] = np.arange(Npop)

    # the inverse of the fitness rank
    rankedFitness = Npop - populationRanks
    
    cumulativeFitness = np.cumsum(rankedFitness)
    probs = cumulativeFitness / cumulativeFitness[-1]
    
    return probs

def pick_Individual(population, probs):
    # Select a mamber of the pupulation at random depending on the ranked probability
    rand = np.random.random()
    selection = population[np.argmax(rand < probs)]
    return selection

def namePopulation(population, gen):
    
    for ii, individual in enumerate(population):
        individual.name = int(ii)
        individual.gen = int(gen)
            